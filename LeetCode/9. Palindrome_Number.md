# [Palindrome Number](https://leetcode.com/problems/palindrome-number/description/)

נתון מספר, ומבקשים לבדוק אם הוא פלינדרום[^1].

לדוגמא:
- `121` הוא פלינדרום, לכן נחזיר `true`.
- `1221` הוא פלינדרום, לכן נחזיר `true`.
- `121-` הוא לא פלינדרום, לכן נחזיר `false`.
- `10` גם לא פלינדרום לכן נחזיר `false`.
## פתרון
מבחינה טכנית, כמובן שאפשר לשנוות את הtype של המספר לString ואז להפוך אותו, אבל זה קצת איטי ותופס מקום, ובנינו, גם לא מאתגר(;  
לשאלה הזאת יש פתרון מתמטי דיי בסיסי, הדרך הפשוטה ביותר להסביר אותה, זה בעזרת דוגמא:  
ניקח מספר `123321` נחלק אותו ב`10`, יצא לנו שארית מספר כלשהו, מה שחשוב לנו היא השארית והיא `1`.  
נשמור את המספר, ונוריד את הספרה האחרונה מהמספר הנתון (נחלק ב10 בלי שארית) ישאר לנו `12332`.  
נחזור על מה שעשינו קודם רק שהפעם לפני שנוסיף את השארית נכפול מה ששמרנו ב`10` `(2+(1 * 10))` ונשמור את זה  
נחזור על הפעולות עד שמה שנשמור יהיה יותר שווה או יותר גדול ממהמספר שאנחנו מחלקים, נשווה בניהם, ונחזיר את זה

## קוד
> [!NOTE]
> - בקוד, נבדוק קודם אם המספר קטן מאפס, או מסתיים ב0, כי אלו תמיד יחזירו False.  
> - ובסוף, נבדוק אם המספר ששמרנו יהיה שווה למספר חלקי 10 בלי שארית, למקרה שהמספר הנתון הוא באורך אי זוגי של ספרות
```python
class Solution1(object):
    def isPalindrome(self, x):
        if(x<0 or (x%10==0 and x!=0)):
            return False
        saved_number=0
        while(x>saved_number):
            saved_number=saved_number*10+x%10
            x/=10
        if (x==saved_number or x==saved_number/10):
            return True
        return False
```

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0 || (x%10==0 && x!=0))
            return false;
        int savedNumber = 0;
        while (x>savedNumber){
            savedNumber = savedNumber * 10 + x%10;
            x/=10;
        }
        if(x==savedNumber || savedNumber/10==x)
            return true;
        return false;
    }
}
```


[^1]: **פָּלִינְדְרוֹם** - הוא מילה, מספר, משפט או כל רצף סמלים אחר, שקריאתו מימין לשמאל ומשמאל לימין היא זהה.
