# [Container with most water](https://leetcode.com/problems/container-with-most-water/)

נתונה רשימה של מספרים, כל מספר מציג "גובה" של עמודה בגרף מסוים (y), כאשר האינדקס מציין את הx שלו.

במילים אחרות, נתון לנו גרף שורות בתור רשימה. ומבקשים מאיתנו למצוא את השטח המקסימלי שאפשר ליצור בין שתי עמודות בגרף כאשר מחברים בניהם בקו ויוצרים מלבן.

לדוגמא: באראי `[1,8,6,2,5,4,8,3,7]` השטח המקסימלי יהיה `49` כאשר נחבר קו בין האיבר במיקום `[1]` שהוא שווה ל`8` לבין האיבר שבמיקום `[8]` שהוא שווה ל`7`, החישוב הוא בעצם כפולה של הפרש המיקומים שלהם - `(8-1)` כפול הגובה של הנמוך מביניהם - `min(7,8)`

<p align="middle">
  <img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExN2gybHI2YXowYjAyaDlyazRxaHRkdWNrd2N3bmQ1d3FkOTh3cW9sbiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zij9unW3i7oLynaerZ/giphy.gif" width="300" height="200">
</p>

## פתרון

<p align="right">
 כמעט כמו כל בעיה, גם את הבעיה הזאת ניתן לפתור עם Brute Force. במקרה הזה, זה אומר לעבור אחד אחד על כל זוג אפשרי של מספרים ברשימה ולחפש את הזוג שאפשר לכלוא ביניהם כמה שיותר מים. הבעיה עם השיטה הזאתי, כרגיל, היא שהיא איטית ולא יעילה: בשביל לעבור על כל זוג אפשרי נצטרך לעשות לולאה בתוך לולאה, וכידוע במצב כזה הסיבוכיות תהיה O(n^2). בשביל לענות על דרישות זמן ההרצה נצטרך למצוא שיטה אחרת לפתור את הבעיה.

  נשמע הגיוני לפתור את החידה עם Dynamic Programming מפני שאנו מתעסקים עם ערכי מקסימום, אך זה לא המקרה. נפתור שאלה בעזרת Dynamic Programming כאשר יש לנו בעיה שניתן לחלק אותה לעוד בעיות קטנות יותר, אשר חוזרות על עצמן. בשאלה הזאתי לא ניתן לפרק את הבעיה לבעיות קטנות יותר שחוזרות על עצמן. במקום זה, מבקשים מאיתנו למצוא שני איברים באראי אשר יוצרים תנאי מסויים. וכאשר זה המקרה, נשתמש בTwo Pointers. אם ננסח מחדש את השאלה, המטרה שלנו היא למצוא את העמודים הכי גדולים והכי רחוקים זה מזה. נפעל באופן הבא:
  
* ניצור שתי מצביעים, אחד יחזיק את מיקום תחילת הרשימה ואחד את מיקום סופה.
* ניצור לולאת while שתרוץ כל עוד המצביעים לא נפגשים, כלומר לולאה אשר תרוץ כל עוד מיקום המצביע השני גדול ממיקום המצביע הראשון.
* בשלב זה נצטרך לבצע בדיקת תנאי מסויים בשביל לדעת איזה אחד מהמצביעים להזיז לקראת המצביע השני. שימו לב: המטרה שלנו היא למצוא 2 עמודים כמה שיותר גדולים ובמרחק כמה שיותר גדול מהם. נניח בהתחלה אנו מצביעים על העמוד הכי שמאלי ועל העמוד הכי ימני. נניח והעמוד הימיני גדול יותר, אז נעדיף לקרב את המצביע השמאלי בתקווה למצוא עמוד גדול יותר. כלומר, בכל ריצה של הלולאה נבדוק איזה עמוד יותר קטן, ונזיז את המצביע של העמוד הקטן כלפי העמוד הגדול יותר. 
* נחשב את שטח המים הכלואים בין העמודים, ונשמור אותו במשתנה.
* נבדוק אם השטח גדול יותר מהשטח הגדול ביותר ששמרנו עד כה, ונעדכן את המשתנה שמחזיק את השטח הגדול ביותר עד כה בהתאם.

על פי זה הכללים האלו נעבור על כל השטחים שפוטנציאלית יהיו הכי גבוהים, ובעזרת שתי המצביעים נמצא את השטח הגדול ביותר.
</p>

## קוד
Python:

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        max_water = 0
        water = 0

        while left < right:
            max_water = max(max_water, water)

            if height[left] < height[right]:
                water = height[left] * (right-left)
                left += 1
            else:
                water = height[right] * (right-left)
                right -= 1

        return max(max_water, water)
```

Java:

```java
public class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxWater = 0;
        int water = 0;

        while (left != right) {
            maxWater = Math.max(maxWater, water);

            if (height[left] < height[right]) {
                water = height[left] * (right - left);
                left++;
            }
            else {
                water = height[right] * (right - left);
                right--;
            }
        }

        return Math.max(maxWater, water);
    }
}
```

**_Complexity Anlysis_**

- _Time Complexity_: O(N)
- _Space Complexity_：O(1)
