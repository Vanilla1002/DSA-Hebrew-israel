# [Container with most water](https://leetcode.com/problems/container-with-most-water/)

נתונה רשימה של מספרים, כל מספר מציג "גובה" של עמודה בגרף מסוים (y), כאשר האינדקס מציין את הx שלו.

במילים אחרות, נתון לנו גרף שורות בתור רשימה. ומבקשים מאיתנו למצוא את השטח המקסימלי שאפשר ליצור בין שתי עמודות בגרף כאשר מחברים בניהם בקו ויוצרים מלבן.

לדוגמא: באראי `[1,8,6,2,5,4,8,3,7]` השטח המקסימלי יהיה `49` כאשר נחבר קו בין האיבר במיקום `[1]` שהוא שווה ל`8` לבין האיבר שבמיקום `[8]` שהוא שווה ל`7`, החישוב הוא בעצם כפולה של הפרש המיקומים שלהם - `(8-1)` כפול הגובה של הנמוך מביניהם - `min(7,8)`

<p align="middle">
  <img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExN2gybHI2YXowYjAyaDlyazRxaHRkdWNrd2N3bmQ1d3FkOTh3cW9sbiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zij9unW3i7oLynaerZ/giphy.gif" width="300" height="200">
</p>

## פתרון

<p align="right">
  הפתרון הפשוט שעולה לכולם לראש הוא brute force כלומר לבדוק כל זוג שורות ברשימה, אך הפתרון הזה מאוד איטי (N^2), לכן נצטרך לפתור אחרת.
  השיטה שנבחר היא two pointers. למה דווקא באלגוריתם הזה? מכיוון שמבקשים מאיתנו למצוא שני איברים באראי אשר יוצרים תנאי מסויים. למרות שרוצים למצוא את המקסימום, הפתרון היותר פשוט ויעיל הוא לא Dynamic Programming מכיוון שרוצים למצוא שני איברים שונים באראי, לכן נשתמש דווקא בtwo pointers. ונפעל כך:
  
* ניצור שתי נקודות, אחת תחזיק את תחילת הרשימה ואחת את השנייה  
* ניצור לולאה שתרוץ כל עוד הנקודות לא נפגשות
* נבדוק איזה נקודה מחזיקה עמודה יותר גבוהה, ועל פי זה נדע להזיז את הנקודה עם הערך הקטן יותר לכיוון השנייה
* ניצור משתנה שישמור את השטח בכל פעם שנעבור
* נבדוק בכל פעם שנעבור אם החישוב יותר גדול מהשטח הגדול ביותר ששמרנו וכך נשנה את הערך

על פי זה הכללים האלו נעבור על כל השטחים שפוטנציאלית יהיו הכי גבוהים, ובעזרת שתי הנקודות נמצא את השטח הגדול ביותר
</p>

## קוד
Python:

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        max_water = 0
        water = 0

        while left != right:
            max_water = max(max_water, water)

            if height[left] < height[right]:
                water = height[left] * (right-left)
                left += 1
            else:
                water = height[right] * (right-left)
                right -= 1

        return max(max_water, water)
```

Java:

```java
public class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxWater = 0;
        int water = 0;

        while (left != right) {
            maxWater = Math.max(maxWater, water);

            if (height[left] < height[right]) {
                water = height[left] * (right - left);
                left++;
            }
            else {
                water = height[right] * (right - left);
                right--;
            }
        }

        return Math.max(maxWater, water);
    }
}
```

**_Complexity Anlysis_**

- _Time Complexity_: O(N)
- _Space Complexity_：O(1)
